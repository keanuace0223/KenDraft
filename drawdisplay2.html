<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map Selection Display - CS2 Style</title>
    <style>
        @font-face {
            font-family: 'Big Noodle Titling';
            src: url('Assets/Font/big_noodle_titling.ttf') format('truetype');
        }
        :root {
            --background-color: #0D0F12;
            --card-color: #1A1C20;
            --font-color: #EAEAEA;
            --accent-color: #A855F7;
            --accent-glow: rgba(168, 85, 247, 0.5);
            --border-color: #3f3f46;
            --active-color: #6c008d;
            --card-width: 200px;
            --card-gap: 16px;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Big Noodle Titling', sans-serif;
            background-color: var(--background-color);
            color: var(--font-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            letter-spacing: 1.5px;
            overflow: hidden;
            scale: 1.4;
        }
        
        h1 {
            margin-bottom: 30px;
            font-size: 4em;
            color: var(--font-color);
            text-shadow: 0 0 10px var(--accent-glow);
        }

        .viewport {
            width: 100%;
            max-width: 1200px;
            height: calc(var(--card-width) * 0.8 + 20px);
            position: relative;
            overflow: hidden;
            -webkit-mask-image: linear-gradient(to right, transparent 0%, black 20%, black 80%, transparent 100%);
            mask-image: linear-gradient(to right, transparent 0%, black 20%, black 80%, transparent 100%);
        }

        .viewport::after {
            content: '';
            position: absolute;
            top: -10px;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            background-color: var(--active-color);
            box-shadow: 0 0 15px 3px var(--active-color);
            z-index: 5;
            border-radius: 2px;
            transition: opacity 1.5s ease-out;
        }

        .viewport.result-decided::after {
            opacity: 0.3;
        }

        .map-reel {
            display: flex;
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
            gap: var(--card-gap);
            padding: 10px 0;
            will-change: transform;
        }

        .map-card {
            width: var(--card-width);
            height: calc(var(--card-width) * 0.8);
            flex-shrink: 0;
            opacity: 0.7;
            /* --- PERUBAHAN: Properti transisi dihapus dari sini untuk menghindari konflik --- */
        }
        
        .map-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .map-card.selected {
            /* --- PERUBAHAN BARU: Menggunakan dua animasi yang dirantai --- */
            /* Animasi pertama untuk masuk, animasi kedua untuk 'bernapas' setelahnya */
            animation: 
                select-and-glow 0.6s ease-out forwards,
                final-breath 2s 0.6s infinite ease-in-out;
            border-color: var(--aura-color, #fff);
        }

        /* --- PERUBAHAN BARU: Keyframe untuk animasi masuk yang halus --- */
        @keyframes select-and-glow {
            from {
                opacity: 0.7;
                transform: scale(1);
                box-shadow: none;
            }
            to {
                opacity: 1;
                transform: scale(1.05);
                box-shadow: 0 0 35px 8px var(--aura-color, #fff);
            }
        }

        @keyframes final-breath {
            0%, 100% { transform: scale(1.05); box-shadow: 0 0 35px 8px var(--aura-color, #fff); }
            50% { transform: scale(1.1); box-shadow: 0 0 55px 15px var(--aura-color, #fff); }
        }

        #status-text {
            font-size: 2.5em; 
            margin-top: 50px; 
            color: var(--font-color); 
            height: 40px; 
            text-shadow: 0 0 8px var(--accent-glow);
        }

        .hide{display: none;}
    </style>
</head>
<body>
    <div class="viewport">
        <div class="map-reel">
        </div>
    </div>
    
    <div class="hide" id="status-text">AWAITING SEQUENCE...</div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const reel = document.querySelector('.map-reel');
            const viewport = reel.parentElement;
            const statusText = document.getElementById('status-text');
            const maps = [
                { name: 'Broken Wall', color: '#a0522d' },
                { name: 'Dangereous Grass', color: '#2e8b57' },
                { name: 'Expanding River', color: '#4682b4' },
                { name: 'Flying Cloud', color: '#add8e6' },
            ];
            
            const REEL_REPEAT_COUNT = 30;
            let animationFrameId;

            function shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            function populateReel() {
                reel.innerHTML = '';
                let reelItems = [];
                for (let i = 0; i < REEL_REPEAT_COUNT; i++) {
                    const items = (i < REEL_REPEAT_COUNT - 3) ? shuffle([...maps]) : [...maps];
                    reelItems.push(...items);
                }

                reelItems.forEach((map, index) => {
                    const card = document.createElement('div');
                    card.className = 'map-card';
                    card.dataset.index = index;
                    card.style.setProperty('--aura-color', map.color);
                    card.innerHTML = `<img src="Assets/map/${map.name}.png" alt="${map.name}">`;
                    reel.appendChild(card);
                });
                return reelItems;
            }

            const reelItems = populateReel();

            function resetDisplay() {
                cancelAnimationFrame(animationFrameId);
                reel.style.transition = 'none';
                reel.style.transform = `translateX(0px)`;
                viewport.classList.remove('result-decided');
                document.querySelectorAll('.map-card.selected').forEach(c => {
                    c.classList.remove('selected');
                    c.style.animation = ''; // Reset animasi
                });
                statusText.textContent = 'AWAITING SEQUENCE...';
            }

            function startAnimation(state) {
                resetDisplay();
                statusText.textContent = 'SPINNING...';

                let finalResult, finalIndex;
                if (state.mode === 'fixed') {
                    finalResult = state.fixedChoice;
                } else {
                    const randomValues = new Uint32Array(1);
                    window.crypto.getRandomValues(randomValues);
                    const combinedValue = randomValues[0] + state.timestamp;
                    finalResult = maps[combinedValue % maps.length].name;
                }
                
                const targetBaseIndex = (REEL_REPEAT_COUNT - 2) * maps.length;
                finalIndex = reelItems.slice(targetBaseIndex).findIndex(m => m.name === finalResult) + targetBaseIndex;

                const winnerCard = document.querySelector(`.map-card[data-index='${finalIndex}']`);
                if (!winnerCard) {
                    console.error("Winner card not found!");
                    return;
                }

                const viewportCenter = viewport.offsetWidth / 2;
                const cardCenter = winnerCard.offsetLeft + (winnerCard.offsetWidth / 2);
                const targetX = viewportCenter - cardCenter;
                
                const duration = 10000;
                const easeOutQuint = t => 1 - Math.pow(1 - t, 5);
                let startTime = null;

                function animationLoop(currentTime) {
                    if (!startTime) startTime = currentTime;
                    const elapsedTime = currentTime - startTime;
                    const progress = Math.min(elapsedTime / duration, 1);
                    const easedProgress = easeOutQuint(progress);

                    const currentX = easedProgress * targetX;
                    reel.style.transform = `translateX(${currentX}px)`;

                    if (progress < 1) {
                        animationFrameId = requestAnimationFrame(animationLoop);
                    } else {
                        reel.style.transform = `translateX(${targetX}px)`;
                        
                        viewport.classList.add('result-decided');
                        winnerCard.classList.add('selected');
                        statusText.textContent = `TARGET ACQUIRED: ${finalResult.toUpperCase()}!`;
                        
                        const finalState = { ...state, status: 'finished', result: finalResult };
                        localStorage.setItem('mapDrawState', JSON.stringify(finalState));
                    }
                }
                animationFrameId = requestAnimationFrame(animationLoop);
            }

            window.addEventListener('storage', (event) => {
                if (event.key === 'mapDrawState') {
                    const newState = event.newValue ? JSON.parse(event.newValue) : null;
                    if (!newState) { 
                        resetDisplay(); 
                        return; 
                    }
                    if (newState.status === 'drawing') { 
                        startAnimation(newState); 
                    }
                }
            });
        });
    </script>
</body>
</html>